# Time compl - O(n^2)
# Space compl - O(n^2)

N = 5
data = []
for i in range(N + 1):
    row = [1] * (i + 1)
    for j in range(i + 1):
        if j != 0 and j != i:
            row[j] = data[i - 1][j - 1] + data[i - 1][j]
    data.append(row)

print(data[N])

# Time compl - O(n)
# Space compl - O(1)

C = 1
print(C, end=" ")
for k in range(1, N + 1):
    C = int(C * (N + 1 - k) / k)
    print(C, end=" ")



# Можешь улучшить первое решение про треугольник паскаля, чтобы M=O(n) ?
# -----------
# Я смог придумать как не хранить все шаги, ведь нам нужен только один - предыдущий, но как сделать в таком
# подходе за "линию", я не догадался.

N = 5
prev_row = [1]
curr_row = [1, 1]

for i in range(2, N + 1):
    next_row = [1] * (i + 1)
    for j in range(1, i):
        next_row[j] = curr_row[j - 1] + curr_row[j]
    prev_row = curr_row
    curr_row = next_row

print()
print(curr_row)


# "Какие общие техники можно применять, чтобы улучшить рекурсивное решение ?"
# ------------
# Насколько я знаю, самый действенный вариант оптимизации - кеширование результатов, что я и применил ниже
# Еще знаю, что можно вместо рекурсии писать итерацию, чтобы не увеличивать стек вызовов

# Time comp (N^2)
# Мы все равно проходимся по всем элементам выше + я подебажил и посмотрел, действительно N^2
# Мне достаточно сложно высчитать самому сложность в рекурсиях, надо закрыть эту дурку в знаниях

# Space comp O((N * (N + 1)) / 2) Исходя их структуры треугольника я вывел такую формулу, она находит сколько
# всего элементов в треугольнике на этаж выше. Для N = 5, (5 * 6 / 2 = 15) 15 биномиальных коэффициентов
# Вижу, что я захватываю еще единички, возможно их хранить не надо, но тогда вырастет стек рекурсий, что тоже
# заберет память

def c(n, k):
    if not k or n == k:
        return 1

    if (n, k) in cache:
        return cache[(n, k)]

    cache[(n - 1, k - 1)] = c(n - 1, k - 1)
    cache[(n - 1, k)] = c(n - 1, k)

    return cache[(n - 1, k - 1)] + cache[(n - 1, k)]

cache = {}
for k in range(N + 1):
    print(c(N, k), end=" ")
print()

# Напиши мне, пожалуйста формулу 1 + 2 + .... + (n - 1) + n
# ------------
# Если я правильно понял, ты хочешь увидеть формулу нахождения суммы N арефм. прогрессии

q = [2, 3, 4, 5, 6]
s = (q[0] + q[-1]) / 2 * len(q)
print(s)  # 20


# Наводящая задача: на входе массив чисел, нужно не используя дополнительной памяти заменить каждое число
# на сумму соседей. Возвращать ничего не нужно, результат - сам изменённый массив.
# ------
# Метод то я написал как инплейс считать сумму соседей, но что-то не навело это меня на формулу подсчета
# треугольника за M = O(n)

def q(data: list) -> list:
    n = len(data)
    if n < 2:
        return data

    data[0] = data[1]
    for i in range(1, n - 1):
        data[i] = data[i - 1] + data[i + 1]
    data[-1] = data[-2]


test_data = [1,3,10, 33, 21, 9, 4, 28]
q(test_data)
print(test_data)
# [3, 13, 46, 67, 76, 80, 108, 108]




